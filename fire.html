<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Campfire</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b1020;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
    .hint {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 13px;
      color: rgba(255, 220, 180, 0.6);
      letter-spacing: 0.04em;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="hint">불을 가만히 바라보세요</div>

<script>
/* =========================
   Canvas Setup
========================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();

/* =========================
   Utils
========================= */
const rand = (a,b)=>a+Math.random()*(b-a);
const lerp = (a,b,t)=>a+(b-a)*t;

function getWind(time) {
  // 시간 기반 자연스러운 바람 (여러 주기 조합)
  return {
    x: Math.sin(time * 0.003) * 0.3 + Math.sin(time * 0.007) * 0.15,
    y: Math.cos(time * 0.005) * 0.1
  };
}

/* =========================
   Fire Particles
========================= */
const particles = [];
let time = 0;
let intensity = 1;
let effectiveIntensity = 1; // 호흡 효과가 적용된 intensity

function fireColor(u) {
  // 다단계 색상 전환: 밝은 노랑 → 주황 → 빨강 → 어두운 빨강
  let r, g, b;
  if (u < 0.3) {
    // 밝은 노랑/흰색 (불꽃 중심)
    r = Math.floor(lerp(255, 255, u / 0.3));
    g = Math.floor(lerp(240, 200, u / 0.3));
    b = Math.floor(lerp(150, 60, u / 0.3));
  } else if (u < 0.7) {
    // 주황색 전환
    const t = (u - 0.3) / 0.4;
    r = Math.floor(lerp(255, 220, t));
    g = Math.floor(lerp(200, 80, t));
    b = Math.floor(lerp(60, 20, t));
  } else {
    // 어두운 빨강/사라짐
    const t = (u - 0.7) / 0.3;
    r = Math.floor(lerp(220, 100, t));
    g = Math.floor(lerp(80, 20, t));
    b = Math.floor(lerp(20, 10, t));
  }
  const a = lerp(0.95, 0.0, Math.pow(u, 0.8)); // 비선형 페이드아웃
  return `rgba(${r},${g},${b},${a})`;
}

function spawnFlame(x, y) {
  const count = Math.floor(10 * effectiveIntensity); // intensity → effectiveIntensity
  for (let i = 0; i < count; i++) {
    const life = rand(50, 80);
    const angle = rand(-Math.PI/3, Math.PI/3); // 위쪽으로 발산
    const speed = rand(1.6, 2.8) * effectiveIntensity; // intensity → effectiveIntensity
    
    particles.push({
      type: "flame",
      x: x + rand(-32, 32), // -16, 16 → -32, 32 (2배)
      y: y + rand(-12, 12), // -6, 6 → -12, 12 (2배)
      vx: Math.sin(angle) * speed * 0.2,
      vy: -Math.cos(angle) * speed,
      size: rand(28, 48), // 14, 24 → 28, 48 (2배)
      life,
      maxLife: life,
      seed: Math.random() * 1000,
      turbulence: rand(0.01, 0.03), // 난류 강도
      depth: rand(0, 1), // 깊이감 (0: 뒤, 1: 앞)
    });
  }
}

function spawnCore(x, y) {
  // 불의 가장 밝은 중심부
  const count = Math.floor(6 * effectiveIntensity); // intensity → effectiveIntensity
  for (let i = 0; i < count; i++) {
    const life = rand(15, 25);
    particles.push({
      type: "core",
      x: x + rand(-16, 16), // -8, 8 → -16, 16 (2배)
      y: y + rand(-6, 6), // -3, 3 → -6, 6 (2배)
      vx: rand(-0.1, 0.1),
      vy: rand(-1.2, -0.8) * effectiveIntensity, // intensity → effectiveIntensity
      size: rand(16, 28), // 8, 14 → 16, 28 (2배)
      life,
      maxLife: life,
      seed: Math.random() * 1000,
      depth: rand(0.3, 1), // 코어는 앞쪽에
    });
  }
}

function spawnSpark(x, y) {
  if (Math.random() > 0.12 * effectiveIntensity) return; // intensity → effectiveIntensity
  const life = rand(20, 40);
  const angle = rand(-Math.PI/2.5, -Math.PI/4); // 비스듬히 위로
  const speed = rand(3.0, 5.0);
  
  particles.push({
    type: "spark",
    x: x + rand(-20, 20), // -10, 10 → -20, 20 (2배)
    y: y + rand(-12, 12), // -6, 6 → -12, 12 (2배)
    vx: Math.sin(angle) * speed * 0.3,
    vy: Math.cos(angle) * speed,
    size: rand(3, 6), // 2, 4 → 3, 6 (1.5배)
    life,
    maxLife: life,
    seed: Math.random() * 1000,
    depth: rand(0, 1),
  });
}

function spawnSmoke(x, y) {
  if (Math.random() > 0.08) return;
  const life = rand(90, 140);
  particles.push({
    type: "smoke",
    x: x + rand(-36, 36), // -18, 18 → -36, 36 (2배)
    y: y + rand(-20, 0), // -10, 0 → -20, 0 (2배)
    vx: rand(-0.2, 0.2),
    vy: rand(-0.7, -0.4),
    size: rand(36, 64), // 18, 32 → 36, 64 (2배)
    life,
    maxLife: life,
    seed: Math.random() * 1000,
    depth: rand(0, 0.5), // 연기는 뒤쪽에
  });
}

function spawnEmber(x, y) {
  // 가끔 큰 불똥이 튐 (크랙링 사운드 시각화)
  if (Math.random() > 0.95) {
    const angle = rand(0, Math.PI * 2);
    const speed = rand(4, 7);
    particles.push({
      type: "ember",
      x: x + rand(-20, 20),
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 3,
      size: rand(4, 8),
      life: rand(40, 60),
      maxLife: 60,
      seed: Math.random() * 1000,
      depth: rand(0.5, 1),
    });
  }
}

/* =========================
   Glow
========================= */
function drawGlow(x, y) {
  const g = ctx.createRadialGradient(x, y, 40, x, y, 440); // 20, 220 → 40, 440 (2배)
  g.addColorStop(0, "rgba(255,180,90,0.5)"); // 0.35 → 0.5 (더 밝게)
  g.addColorStop(0.6, "rgba(255,140,60,0.2)"); // 0.15 → 0.2
  g.addColorStop(1, "rgba(10,15,30,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, 440, 0, Math.PI * 2); // 220 → 440 (2배)
  ctx.fill();
}

function drawGroundReflection(x, y, breathe) {
  // 바닥에 불빛 반사 (환경광)
  const reflectionIntensity = 0.15 * breathe;
  const g = ctx.createRadialGradient(x, y + 100, 0, x, y + 100, 200);
  g.addColorStop(0, `rgba(255,120,40,${reflectionIntensity})`);
  g.addColorStop(1, "rgba(255,120,40,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y + 100, 200, 0, Math.PI * 2);
  ctx.fill();
}

function drawFlame(x, y, size, color, seed) {
  // 원 대신 불규칙한 형태
  ctx.fillStyle = color;
  ctx.beginPath();
  
  const points = 8;
  for (let i = 0; i < points; i++) {
    const angle = (i / points) * Math.PI * 2;
    const noise = Math.sin(seed + i * 0.7) * 0.3 + 0.7; // 불규칙성
    const offset = size * noise;
    const stretchY = i < points / 2 ? 1.4 : 1.0; // 위쪽으로 늘림
    const px = x + Math.cos(angle) * offset;
    const py = y + Math.sin(angle) * offset * stretchY;
    
    if (i === 0) {
      ctx.moveTo(px, py);
    } else {
      ctx.lineTo(px, py);
    }
  }
  
  ctx.closePath();
  ctx.fill();
}

function drawLogs(x, y) {
  // 불이 타는 장작 표현 (2배 크기)
  ctx.save();
  
  // 장작 1 (왼쪽)
  ctx.fillStyle = "rgba(40, 30, 20, 0.95)";
  ctx.fillRect(x - 140, y + 40, 120, 28); // x-70, y+20, 60, 14 → 2배
  
  // 그을린 효과 (장작 1)
  ctx.fillStyle = "rgba(15, 10, 5, 0.7)";
  ctx.fillRect(x - 136, y + 40, 30, 28); // x-68, y+20, 15, 14 → 2배
  
  // 장작 2 (오른쪽, 기울어진)
  ctx.save();
  ctx.translate(x + 70, y + 54); // x+35, y+27 → 2배
  ctx.rotate(Math.PI / 9);
  ctx.fillStyle = "rgba(45, 35, 25, 0.95)";
  ctx.fillRect(-60, -14, 120, 28); // -30, -7, 60, 14 → 2배
  
  // 그을린 효과 (장작 2)
  ctx.fillStyle = "rgba(15, 10, 5, 0.7)";
  ctx.fillRect(-56, -14, 24, 28); // -28, -7, 12, 14 → 2배
  ctx.restore();
  
  // 장작 3 (중앙 뒤쪽, 작게)
  ctx.fillStyle = "rgba(35, 25, 18, 0.8)";
  ctx.fillRect(x - 50, y + 56, 100, 20); // x-25, y+28, 50, 10 → 2배
  
  ctx.restore();
}

/* =========================
   Main Loop
========================= */
function update() {
  time++;

  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#0b1020";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  const baseX = innerWidth * 0.5;
  const baseY = innerHeight * 0.72;

  // intensity decay
  intensity = Math.max(1, intensity * 0.985);
  
  // 불의 호흡 효과 (주기적으로 강해졌다 약해짐)
  const breathe = Math.sin(time * 0.01) * 0.3 + 1.0; // 0.7 ~ 1.3
  const effectiveIntensity = intensity * breathe;

  // glow (호흡에 따라 밝기 조절)
  ctx.globalCompositeOperation = "source-over";
  const glowIntensity = 0.5 * breathe; // 호흡 효과 반영
  const g = ctx.createRadialGradient(baseX, baseY + 20, 40, baseX, baseY + 20, 440);
  g.addColorStop(0, `rgba(255,180,90,${glowIntensity})`);
  g.addColorStop(0.6, `rgba(255,140,60,${glowIntensity * 0.4})`);
  g.addColorStop(1, "rgba(10,15,30,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(baseX, baseY + 20, 440, 0, Math.PI * 2);
  ctx.fill();
  
  // 바닥 반사광 추가
  drawGroundReflection(baseX, baseY, breathe);

  // logs (장작은 불 아래에)
  drawLogs(baseX, baseY);

  // spawn
  spawnFlame(baseX, baseY);
  spawnCore(baseX, baseY);
  spawnSpark(baseX, baseY);
  spawnSmoke(baseX, baseY);
  spawnEmber(baseX, baseY); // 불똥 추가

  ctx.globalCompositeOperation = "lighter";

  const wind = getWind(time);

  // 깊이 순서로 정렬 (뒤에서 앞으로)
  particles.sort((a, b) => (a.depth || 0) - (b.depth || 0));

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
      continue;
    }

    const u = 1 - p.life / p.maxLife;
    const wobble = Math.sin(time * 0.05 + p.seed) * 0.25;

    if (p.type === "core") {
      p.x += p.vx;
      p.y += p.vy;
      
      // 밝은 중심부 렌더링 (그라데이션)
      const depthScale = 0.7 + (p.depth || 0.5) * 0.3;
      const r = p.size * (1 - u * 0.5) * depthScale;
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
      grad.addColorStop(0, `rgba(255, 255, 240, ${0.9 * (1-u)})`);
      grad.addColorStop(0.4, `rgba(255, 200, 80, ${0.7 * (1-u)})`);
      grad.addColorStop(1, `rgba(255, 120, 20, 0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    if (p.type === "flame") {
      p.vx += wobble * 0.02 + wind.x * 0.02;
      p.vy += wind.y * 0.01;
      p.vx *= 0.98;
      p.vy *= 0.995;
      
      // 난류 효과
      if (p.turbulence) {
        p.vx += (Math.random() - 0.5) * p.turbulence;
      }
      
      p.x += p.vx;
      p.y += p.vy;

      const depthScale = 0.7 + (p.depth || 0.5) * 0.3;
      const r = p.size * (1 - u * 0.7) * depthScale;
      drawFlame(p.x, p.y, r, fireColor(u), p.seed);
    }

    if (p.type === "spark") {
      p.vy += 0.1;
      p.x += p.vx;
      p.y += p.vy;
      const depthScale = 0.7 + (p.depth || 0.5) * 0.3;
      const sparkSize = p.size * depthScale;
      ctx.fillStyle = `rgba(255,220,160,${1-u})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sparkSize, 0, Math.PI * 2);
      ctx.fill();
    }

    if (p.type === "smoke") {
      ctx.globalCompositeOperation = "source-over";
      p.vx += wind.x * 0.05; // 연기는 바람 영향 더 받음
      p.vy += wind.y * 0.03;
      p.x += p.vx + wobble * 0.01;
      p.y += p.vy;
      const depthScale = 0.7 + (p.depth || 0.5) * 0.3;
      ctx.fillStyle = `rgba(210,220,255,${(1-u)*0.15})`;
      ctx.beginPath();
      ctx.arc(
        p.x,
        p.y,
        p.size * (0.6 + u) * depthScale,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.globalCompositeOperation = "lighter";
    }
    
    if (p.type === "ember") {
      p.vy += 0.15; // 중력
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.98; // 공기 저항
      
      const depthScale = 0.7 + (p.depth || 0.5) * 0.3;
      const emberSize = p.size * depthScale;
      
      // 뜨거운 불똥 효과 (외부 glow)
      const glowSize = emberSize * 2;
      ctx.fillStyle = `rgba(255,100,30,${(1-u)*0.3})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
      ctx.fill();
      
      // 밝은 중심
      ctx.fillStyle = `rgba(255,200,100,${1-u})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, emberSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if (particles.length > 1200) { // 600 → 1200 (2배)
    particles.splice(0, particles.length - 1200);
  }

  requestAnimationFrame(update);
}

update();

/* =========================
   Interaction (Boost)
========================= */
window.addEventListener("click", () => {
  intensity = Math.min(intensity + 1.6, 3.5);
});
</script>
</body>
</html>
